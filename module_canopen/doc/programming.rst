Programming Guide=================The application uses CAN bus to run the CANopen module.Installing the component------------------------The *CANopen Slave* component can be installed via the xSOFTip browser in the xTIMEcomposer or downloaded via http://www.xmos.com.Dependencies------------To use the module you should confirm that ``module_canopen``, ``module_can`` and ``module_mutual_thread_comm`` are present in the ``USED_MODULES`` variable in your application Makefile. This module uses CAN bus communication to transfer CAN frames.File Preparation----------------The application should contain the files ``canopen_conf.h``, ``can_conf.h`` and ``object_dictionary.h``.#. The file ``can_conf.h`` must be provided in the application source code, and it must define:   PROP_SEG,   PHASE_SEG1,   PHASE_SEG2,   CAN_CLOCK_DIVIDE   information on configuration of these parameters are available in the API section of ``module_can``. Example configuration settings are shown below:    .. literalinclude:: module_canopen/can_conf_example.h      :start-after: //::CAN Conf      :end-before: //::CAN Conf End#. The file ``canopen_conf.h`` must be provided in the application source code, it must define :   CANOPEN_NODE_ID,   HEARTBEAT_SUPPORTED,   CANOPEN_NUMBER_OF_TPDOS_SUPPORTED,   CANOPEN_NUMBER_OF_RPDOS_SUPPORTED,   CANOPEN_MAX_DATA_BUFFER_LENGTH   **CANOPEN_NODE_ID**      Node ID of CANopen Slave device.         **HEARTBEAT_SUPPORTED**      Define this as 1 to select Heartbeat monitoring. If defined as 0, Node guard is implemented.       **CANOPEN_NUMBER_OF_TPDOS_SUPPORTED**      Number of transmit PDOs required by the application.         **CANOPEN_NUMBER_OF_RPDOS_SUPPORTED**      Number of receive PDOs required by the application.      **CANOPEN_MAX_DATA_BUFFER_LENGTH**      Maximum Data buffer length for data in object dictionary.         Example configuration defines in canopen_conf.h file are as shown:    .. literalinclude:: module_canopen/canopen_conf_example.h      :start-after: //::Conf      :end-before: //::Conf End #. The file ``object_dictionary.h`` must be provided in the application source code. This file is generated automatically based on the Electronic Data Sheet(EDS) file. Details on how to generate the ``object_dictionary.h`` file is available in the Programming section of the Document.  object_dictionary.h+++++++++++++++++++The ``object_dictionary.h`` file is generated based on an EDS file by using the ``od_generator.py`` script. The script is available in ``object_dictionary_generator`` folder of the module.    Once the EDS file is ready with your required device profile and required objects, run the script ``od_generator.py``. The script will generate the ``object_dictionary.h`` file based on the input NODE ID and name of the EDS file.Then add the ``object_dictionary.h`` file to the application. An example is available in the module named ``object_dictionary_example.h``.   Install python on the host and run the script as shown below::   python od_generator.pyPort I/O Setup--------------The application must define ports to use for the CAN interface. CAN ports can be defined as shown in the example below::   on tile[0]: can_ports p = {                                XS1_PORT_1L,                                 XS1_PORT_1I,                                 XS1_CLKBLK_1                              };                                 on tile[0]: port shutdown = XS1_PORT_4E;Information on port configuration is available in the ``port configuration`` section of ``module_can``.    Application-----------Application can be instantiated as shown::   int main()   {     streaming chan c_application;     chan c_rx_tx;       par     {       on tile[0]:{           shutdown <: 0;           can_server(p, c_rx_tx);       }       on tile[0]: canopen_server(c_rx_tx, c_application);       on tile[1]: application(c_application);     }     return 0;   }Sample application function can be described as shown::   void application(streaming chanend c_application)   {     timer t;     unsigned time;     unsigned char pdo_data[8];       select     {       case c_application:> char pdo_number:          canopen_client_receive_data_from_stack(c_application, length,data);         //add your code        break;           case t when timerafter(time+100000000):>time:         canopen_client_send_data_to_stack(c_application, 2, 1, pdo_data);       break;     }   }   The above example application receives the PDO information from the CANopen module using channel ``c_application`` and does some operations on receiving data. It transmits PDO data to the CANopen module for every One second using timer event.   Data Passing Over Channel (c_rx_tx)----------------------------------- Messages are communicated between CANopen module and the CAN module using the channel ``c_rx_tx``. Messages are processed based on the message types. Different types of messages that are supported by CANopen module are listed below.   * Network Management (NMT)    * Synchronization Message (SYNC)   * Layer Settings Service (LSS)   * Service Data Objects (SDO)   * Receive Process Data Objects (RPDO)   * Transmit Process Data Objects (TPDO)   * Emergency Messages (EMCY)   * HEARTBEAT    * NODE GUARDInformation on the functions that are used to process these messages are available in the API section of the Document.Data passing over channel (c_application)----------------------------------------- PDO communication is done between CANopen module and application using the channel ``c_application``. Different types of PDO communication types are listed below:    * Acyclic Synchronous   * Cyclic Synchronous   * RTR request Asynchronous   * RTR request Synchronous   * Asynchronous   Information on the functions that are used to communicate these messages are available in the API section of the Document.