Programming Guide=================Installing the component------------------------The *CANopen Slave* component can be installed via the xSOFTip browser in the xTIMEcomposer or downloaded via http://www.xmos.com.Dependencies------------To use the module you should confirm that ``module_canopen``, ``module_can`` and ``module_mutual_thread_comm`` are present in the ``USED_MODULES`` variable in your application Makefile.File Preparation----------------The application should contain the files ``canopen_conf.h``, ``can_conf.h`` and ``object_dictionary.h``.  object_dictionary.h+++++++++++++++++++The ``object_dictionary.h`` file is generated based on an EDS file by using the ``od_generator.py`` script. The script is available in ``object_dictionary_generator`` folder of the module.    Once the EDS file is ready with your required device profile and required objects, run the script ``od_generator.py``. The script will generete the ``object_dictionary.h`` file based on the input NODE ID and name of the EDS file.Then add the ``object_dictionary.h`` file to the application. An example is available in the module named ``object_dictionary_example.h``.   Install python on the host and run the script as shown below::   python od_generator.pyPort I/O Setup++++++++++++++The application must define ports to use for the CAN interface. CAN ports can be defined as shown in the example below::   on tile[0]: can_ports p = {                                XS1_PORT_1L,                                 XS1_PORT_1I,                                 XS1_CLKBLK_1                              };                                 on tile[0]: port shutdown = XS1_PORT_4E;Information on port configuration is available in the ``port configuration`` section of ``module_can``.    Application+++++++++++Application can be instantiated as shown::   int main()   {     streaming chan c_application;     chan c_rx_tx;       par     {       on tile[0]:{           shutdown <: 0;           can_server(p, c_rx_tx);       }       on tile[0]: canopen_server(c_rx_tx, c_application);       on tile[1]: application(c_application);     }     return 0;   }Sample application function can be described as shown::   void application(streaming chanend c_application)   {     timer t;     unsigned time;     unsigned char pdo_data[8];       select     {       case c_application:> char pdo_number:          canopen_client_receive_data_from_stack(c_application, length,data);         //do something       break;           case t when timerafter(time+100000000):>time:         canopen_client_send_data_to_stack(c_application, 2, 1, pdo_data);       break;     }   }   The above example application receives the PDO information from the CANopen module using channel ``c_application`` and does some operations on receiving data. It transmits PDO data to the CANopen module for every One second using timer event.   Data Passing Over Channel (c_rx_tx)+++++++++++++++++++++++++++++++++++ The ``module_canopen``, communciation of CAN frames from the master using the channel ``c_rx_tx`` and process the data based on the message type. Different messsage types are listed below:Received Messages:   * Network Management (NMT)    * Synchronization Message (SYNC)   * Layer Settings Service (LSS)   * Service Data Objects (SDO)   * Receive Process Data Objects (RPDO)   * NODE GUARDTransmit Messages:   * Transmit Process Data Objects (TPDO)   * Service Data Objects (SDO)   * Emergency Messages (EMCY)   * NODE GUARD    * HEARTBEAT Data passing over channel (c_application)+++++++++++++++++++++++++++++++++++++++++ The ``module_canopen``, communication of PDO messages is done using the channel ``c_application`` and based on the transmission type it send or receive PDO data. Different types of PDO communication types are listed below:   * Acyclic Synchronous   * Cyclic Synchronous   * RTR request Asynchronous   * RTR request Synchronous   * Asynchronous   